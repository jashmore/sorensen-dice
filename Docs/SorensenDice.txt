

Daniel Jordan
Datblygwr Meddalwedd | Software Develper
Tîm Porth Clinigol Cymru | Welsh Clinical Portal Team
Gwasanaeth Gwybodeg GIG Cymru | NHS Wales Informatics Service
Tel|Ffon:         029 2050 3278 
WHTN:            01790 3278
Ebost|Email:   Daniel.Jordan@wales.nhs.uk
 

From: Rhodri Evans (NWIS - Software Development) <Rhodri.Evans3@wales.nhs.uk> 
Sent: 16 September 2019 09:28
To: James Cooper (NWIS - Software Development) <James.Cooper@wales.nhs.uk>; Daniel Jordan (NWIS - Software Development) <Daniel.Jordan@wales.nhs.uk>; Dwaine Harding (NWIS - Software Development) <Dwaine.Harding@wales.nhs.uk>
Cc: Alex Paes (NWIS - Software Development) <Alex.Paes@wales.nhs.uk>
Subject: RE: Sorenson Dice Coefficient

If anyone could explain what the bit shifting is doing below I might stand a fighting chance of getting it into t-sql

From: James Cooper (NWIS - Software Development) <James.Cooper@wales.nhs.uk> 
Sent: 16 September 2019 08:18
To: Daniel Jordan (NWIS - Software Development) <Daniel.Jordan@wales.nhs.uk>; Dwaine Harding (NWIS - Software Development) <Dwaine.Harding@wales.nhs.uk>; Rhodri Evans (NWIS - Software Development) <Rhodri.Evans3@wales.nhs.uk>
Cc: Alex Paes (NWIS - Software Development) <Alex.Paes@wales.nhs.uk>
Subject: FW: Sorenson Dice Coefficient

Hi Guys,

I’m off sick today but I wanted to send you this from Steve Shering.  He asked for the Radiology test selector be updated to use this algorithm instead.  I’ve converted this into C# and Shelved it as SorensenDice but I haven’t looked at integrating this with the form (step 5 below).

The issue is that it relies on having the “fingerprint” for the examinations, which we don’t have.  Can someone contact Rhodri or Rob Jones regarding this and see what they can do?

Interestingly, this algorithm is well known and you can search for C# implementations and these differ from what Steve has given below.  It might be worth comparing them to the shelveset in terms of efficiency and performance.

Steve wants this to be the standard way of searching for things so this is going to come up a lot.

Any issues email me and I’ll pick them up on my work phone.

Thanks,
James


From: Stephen Shering (NWIS - Clinical) 
Sent: 09 June 2017 14:05
To: Robert Jones (NWIS - Applications Design) <rob.jones@wales.nhs.uk>
Subject: Sorenson Dice Coefficient

Hi.

Concise explanation here: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient

Short summary for strings and bigrams (letter pairs). Break strings up into overlapping letter pairs (start and end count as a letter). “word” becomes [#w, wo, or, rd, d#]. A pair is a characteristic of the string. The set of a string’s characteristics is the string’s fingerprint. If two strings are the same, their fingerprints will be the same. If they are a little bit different, their fingerprints will be a little bit different, but almost the same. Word order changes and common typos result in small fingerprint differences. Closeness of fingerprints can be quantified as ration of intersection to union of characteristics (as in lots of stats).

Fortuitously, a letter pair can usually be represented as a machine integer, fingerprints can be pre-computed and stored and sets of machine integers can be compared efficiently.

In Java:

Step 1: “normalise” the strings

  public static String normalise(String s) {
    s=s.replaceAll("'", "");
    s=s.replaceAll("-", " ");
    while (s.indexOf("  ")!=-1)
      s=s.replaceAll("  ", " ");
    return s.toLowerCase();
    }
Step 2: compute fingerprint: 
  
  public static int[] sfp(String s) {
    if (s==null)
      return null;
    s=normalise(s);
    int len=s.length();
    int[] fp=new int[len];
    for (int i=0; i<len; i++) {
      fp[i]=s.charAt(i) << 8;
      if (i!=0)
        fp[i-1]|=s.charAt(i);
      ;}
    Arrays.sort(fp);
    return fp;
    }
Step 3: count intersection of two fingerprints: 
  
  public static int intersection(int[] fp1, int[] fp2) {
    int matches=0;
    int i=0;
    int j=0;
    while (i<fp1.length && j<fp2.length) {
      if (fp1[i]==fp2[j]) {
        matches++;
        i++;
        j++;
        ;}
      else if (fp1[i]<fp2[j])
        i++;
      else
        j++;
      ;}
    return matches
    ;}

Step 4: Calculate the ratio of intersection to union:

  public static double sdi(int[] fp1, int[] fp2) {
    //the “double” forces fp division
    //otherwise java uses integer division and the result here is always 0 or 1
    double score=intersection(fp1, fp2);
    return (2*score)/(fp2.length+fp1.length);
    }

Step 5:  For search term st, find bestMatch codebook entry with highest ratio by brute force.

      int[] stfp=util.sfp(st);
      sgs.sno3.model.term bestMatch=null;
      double bestIndex=0.0;
      bestMatch=null;
      for (term dt: db.db.findingTerms) {
        double index=util.sdi(stfp,  dt.sfp);
        if ((bestMatch==null) || (index>bestIndex)) {
          bestIndex=index;
          bestMatch=dt;
          }
        }
Should mention that Sorenson-Dice is not a true “metric”, so codebook cannot be partitioned, so binary tree like searches (VP trees, KD trees, etc) cannot be used, so brute force search needed. But in my experiments using true metrics, for this application, partitioning does not work very well, so most of codebook has to be searched anyway (embarrassingly, it appears that this is a well-known problem called “curse of dimensionality”), and extra complexity (plus inefficiency of most true metrics) outweighs any benefits (as you saw, it’s more than fast enough).

Steve.


